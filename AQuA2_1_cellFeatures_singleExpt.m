%% AQuA2_CFU.m read metadata file from AQuA2 and CFU GUI. 
% For all events detected, it gives 15 values/features, including: Index number (=event number), in sequential order,
% area, circularity, max Dff, duration, etc, for all events. The new AQuA2 also outputs information about detected cells ("CFU") which 
% is provided as cfuInfo1/2, depending on the channel chosen. It gives the list of cells detected and their corresponding list of events.
% This detection has to be somewhat manual, in order to adjust overlap threshold (important!!!) and identify areas where detection is not clear

clear all;
clc;

spreadsheetPath = 'R:\Levy Lab\2photon\ImagingDatasets_Simone_241017.xlsx';
sheet = 'Macrophage';
dataTable = readcell(spreadsheetPath, 'sheet',sheet);  
colNames = dataTable(1,:); %remove all info and leave just column names
dataTable(1,:) = []; %remove column names

dataCol = struct( ...
    'mouse',find(contains(colNames, 'Mouse')), ...
    'date',find(contains(colNames, 'Date')), ...
    'FOV',find(contains(colNames, 'FOV')), ...
    'run',find(contains(colNames, 'Runs')));

% Convert the numeric values in the date column to strings, regardless of their original data type
dataTable(:,dataCol.date) = cellfun(@num2str, dataTable(:,dataCol.date), 'UniformOutput',false); 

% --- Specify the row number of interest
rowOfInterest = 365; 

% Extract information from the specified row
mouse = dataTable{rowOfInterest, dataCol.mouse};
date = dataTable{rowOfInterest, dataCol.date};
fov = dataTable{rowOfInterest, dataCol.FOV};
run = dataTable{rowOfInterest, dataCol.run};

%% Load metadata files generated by AQuA

folderPath = fullfile('D:\2photon\Simone\Simone_Macrophages\', mouse, '\', [date '_FOV' num2str(fov)], '\AQuA2\');
%substackOptions = {'Substack(1-900)', 'Substack(901-1800)'};  % Add more options if needed

% List the contents of the folder
contents = dir(folderPath);

% Exclude '.', '..', and 'Thumbs.db' entries, so 'contents' contains only the actual files and folders in the directory
excludeList = {'.', '..', 'Thumbs.db'};
contents = contents(~ismember({contents.name}, excludeList));

% Initialize subfolder name
subfolderName = '';

%% Loop through the contents and find the subfolder with 'Substack' in its name
for s = 1:numel(contents)
    if contents(s).isdir && contains(contents(s).name, 'Substack') 
        subfolderName = contents(s).name;
        disp(subfolderName);

        % Construct the file path for CFU based on the information from the spreadsheet
        AQuA2_CFUinfo_filePath = fullfile( ...
        'D:\2photon\Simone\Simone_Macrophages\', mouse, '\', [date '_FOV' num2str(fov)], '\AQuA2\', [subfolderName, '_AQuA_res_cfu']);
        AQuA2_CFUinfo = load(AQuA2_CFUinfo_filePath);

        % Construct the file path for AQuA results based on the information from the spreadsheet
        AQuA2_Feature_filePath = fullfile( ...
        'D:\2photon\Simone\Simone_Macrophages\', mouse, '\', [date '_FOV' num2str(fov)], '\AQuA2\', ...
        [subfolderName, '\'], [subfolderName, '_AQuA2']);
        AQuA2_Feature = load(AQuA2_Feature_filePath);

        % Set the output directory to save files
        outputDirFOV = fileparts(AQuA2_CFUinfo_filePath);
        cd(outputDirFOV); %change directory of current folder                
        outputDirAnimal = fullfile('D:\2photon\Simone\Simone_Macrophages\', mouse, '\', 'AQuA2_Results\'); %set directory of animal folder for AQuA2 results
        [filepath,name,ext] = fileparts(AQuA2_CFUinfo_filePath);
        fileTemp = extractBefore(name, "_AQuA_res_cfu");   

        % CFU map - Show all cells in a grid figure - Assuming your cell array is named 'cfuInfo1'
        % Determine the number of cells in the array
        numCells = size(AQuA2_CFUinfo.cfuInfo1, 1);
        
        % Determine the number of rows and columns for the subplot arrangement
        numRows = ceil(sqrt(numCells));
        numColumns = ceil(numCells / numRows);
        
        % Create a new figure for all subplots
        cells = figure;
        
        for cellIndex = 1:numCells
            % Access the cell map based on the current iteration
            cellMap = AQuA2_CFUinfo.cfuInfo1{cellIndex, 3};
        
            % Create a logical mask for non-zero values
            nonZeroMask = cellMap > 0;
        
            % Create subplots in a grid
            subplot(numRows, numColumns, cellIndex);
        
            % Display the cell map with only non-zero values
            imshow(nonZeroMask);
        
            % Add a title to each subplot
            title(['Cell ', num2str(cellIndex)]);
        end
        %Save CFU map figure
        saveas(cells, fullfile(outputDirFOV,strcat(fileTemp,"_combined_cells_figure_complete.png")));
        saveas(cells, fullfile(outputDirAnimal,strcat(fileTemp,"_combined_cells_figure_complete.png")));

        % Create a table (finalResults) with final results of all cells and median of features
        % Features to remove 
        featuresIndicesToDelete = [1,3,7,15,16,17,18,19,20,21,22,23,24];
        
        %Get metadata results of ALL events
        resultsRaw = AQuA2_Feature.res.featureTable1;
        resultsExpanded = cell2table(resultsRaw.ftsTb); %expanded events without features column
        resultsExpanded(featuresIndicesToDelete,:) = [];
        
        %Create a resultsFinal table of features
        results = resultsRaw; %copy of metadata results table
        results.ftsTb = []; %assign empty values
        results(featuresIndicesToDelete,:) = []; %remove features

        %Add new features to resultsFinal table    
        existingRowNames = results.Properties.RowNames; % Getting the existing row names
        newRowNames = {'Number of Events'; 'Cell location (0,perivascular;1,adjacent;2,none)'; 'Red label'; 'dFF'};
        updatedRowNames = [existingRowNames; newRowNames];
        newRowsData = zeros(4, width(results));   % Adding new rows to the table (e.g., with zeros)
        results = [results; array2table(newRowsData, 'VariableNames', results.Properties.VariableNames)];
        results.Properties.RowNames = updatedRowNames; % Setting the updated row names to the table
        
        % Results of CFU
        % Initialize variables and create a table
        cellList = AQuA2_CFUinfo.cfuInfo1(:,1); 
        eventList = AQuA2_CFUinfo.cfuInfo1(:,2);
        dFF_list = AQuA2_CFUinfo.cfuInfo1(:,6);
        resultsTable = table(cellList, eventList, dFF_list);
        
        % Transform table to struct array
        resultsTable = table2struct(resultsTable);
        
        % Ask the user to enter multiple sets of cells to merge
        cellsToMerge = input('Enter ID of cells to merge (e.g., [1,2] OR [1,2;3,4] OR {[1,2]; [3,4,5]}): ');

        % Check if all cells have the same length   
        if iscell(cellsToMerge)
            % Check if all cells have the same length
            firstLength = length(cellsToMerge{1});
            sameLength = all(cellfun(@(x) length(x) == firstLength, cellsToMerge));
            if sameLength
                disp('All cells have the same length.');
            else %If cellsToMerge does not have same length
            % Find the maximum length of the sub-arrays
            maxLength = max(cellfun(@length, cellsToMerge));        
            % Pad each sub-array with NaN to make them the same length
            paddedData = cellfun(@(x) [x, NaN(1, maxLength - length(x))], cellsToMerge, 'UniformOutput', false);       
            % Convert to matrix
            cellsToMerge = cell2mat(paddedData);  
            end
        end
               
        % Ask the user to enter ID of perivascular cells
        perivascularCells = input('Enter ID of perivascular cells (e.g., [1,2,3,4]): ');

        % Ask the user to enter ID of cells adjacent to the vasculature
        adjacentCells = input('Enter ID of cells adjacent to the vasculature (e.g., [1,2,3,4]): ');

        % Ask the user to enter ID of cells labelled with red
        redLabel = input('Enter ID of cells labelled with red (e.g., [1,2,3,4]): ');

        % Check if userInput is valid (you may want to add more validation)
        if ismatrix(cellsToMerge)                      
        % Iterate through cellsToMerge
            for m = 1:size(cellsToMerge, 1)
                % Extract cell indices to merge
                cellIndices = cellsToMerge(m, :);
                validIndices = ~isnan(cellIndices);
                validCellIndices = cellIndices(validIndices);
        
                % Combine events of CFUs
                combinedCellEvents = cat(1, resultsTable(validCellIndices).eventList);
                % Update the first CFU with the combined events
                resultsTable(validCellIndices(1)).eventList = combinedCellEvents;

                % Extract dFF values for the specified cell indices
                dFF_values_to_combine = cell2mat(dFF_list(validCellIndices));
                combined_dFF = mean(dFF_values_to_combine);
                % Update the first CFU with the combined dFF
                resultsTable(validCellIndices(1)).dFF_list = combined_dFF;
            end

            % Remove the extra CFUs
            cellsToMergeCell = cell(size(cellsToMerge));
            for i = 1:size(cellsToMerge, 1)
                for c = 1:size(cellsToMerge, 2)
                    if isnan(cellsToMerge(i, c))
                        cellsToMergeCell{i, c} = [];
                    else
                        cellsToMergeCell{i, c} = cellsToMerge(i, c);
                    end
                end
            end

            valuesToRemove = cat(1, cellsToMergeCell{:, 2:end});
            resultsTable(valuesToRemove,:) = [];
       
            % End of the block for processing user input for each set of cells
        else
            disp('Invalid input. Please enter valid cell indices.');
            cellsToMerge = input('Enter pairs of cells to merge (e.g., [1,2; 3,4]): ');
        end             
               
        % Ask the user to enter the events to remove from the analysis
        eventsToDelete = input('Enter events to remove (e.g., [1,2,3,4]): ');

        %List of cells ID after merging
        validCells = vertcat(resultsTable.cellList);
        
        % Iterate through CFU cell array
        for rowNumber = 1:size(resultsTable,1)
         
            % From one cell, extract its ID and its list of events - do for all cells
            cellID = resultsTable(rowNumber).cellList;
            cellEvents = resultsTable(rowNumber).eventList;
            numberOfEvents = size(cellEvents,1);
           
            % Initialize an array to store median values for a group of events          
            EventFeatures = table2array(resultsExpanded(:,cellEvents));        
           
            if ~isempty(eventsToDelete)
                for j = 1:numel(eventsToDelete)
                    eventToDelete = eventsToDelete(j);                              
    
                    % Check if the event exists in cellEvents{1, 1}
                    if ismember(eventToDelete, cellEvents)
                        % Find and remove columns in EventFeatures corresponding to events to delete
                        columnsToDelete = ismember(cellEvents, eventToDelete);
                        cellEvents(columnsToDelete,:) = [];
                        EventFeatures(:, columnsToDelete) = [];
                        %update number of events
                        numberOfEvents = size(EventFeatures,2);

                    else
                        disp(['Event ', num2str(eventToDelete), ' not found for Cell ', num2str(cellID)]);
                    end
                end
            end
            
            %Calculate median of the remaining events
            EventFeatures_median = array2table(median(EventFeatures,2),'VariableNames',{['Cell ' num2str(cellID)]});

            % Pad EventFeatures_median with NaNs to make it have the same number of rows as resultsFinal
            missingRows = size(results, 1) - size(EventFeatures_median, 1);
            emptyRows = array2table(NaN(missingRows, width(EventFeatures_median)), 'VariableNames', EventFeatures_median.Properties.VariableNames);
            EventFeatures_median = [EventFeatures_median; emptyRows];
            
            % Populate resultFinal table with median of rows 1-11
            results = [results, EventFeatures_median]; %median of each cell, all features, iterating cell in cellList
            
            % Populate resultFinal table with new rows 

            %Row 12 - number of events per cell
            results{12,rowNumber} = numberOfEvents;

            %Row 13 - cell location
            % Check if the column index is found
            if ismember(cellID, perivascularCells)
                results{13, rowNumber} = 0;
            elseif ismember(cellID,adjacentCells)
                results{13, rowNumber} = 1;
            else
                results{13,rowNumber} = 2;
            end

            %Row 14 - labelled with red dextran
            if ismember(cellID, redLabel)
                results{14, rowNumber} = 1;
            else ismember(cellID,redLabel)
                results{14, rowNumber} = 0;
            end
        end

        results(1, :) = []; %remove Index row (Event number)

        %Create a cell array from table to populate dFF
        resultsFinal = rows2vars(results, "VariableNamingRule","preserve");

        %Column 15 - dFF 
        resultsFinal.dFF = arrayfun(@(x) {x}, resultsFinal.dFF); % Convert row to cell array type
        resultsFinal.dFF = {resultsTable.dFF_list}';

        %Adjustments of resultsFinal table before saving
        rows_with_nan = any(ismissing(resultsFinal), 2); %dimension 2(rows)
        resultsFinal = resultsFinal(~rows_with_nan, :);

        updatedColumnNames = {'Cell ID', ...
            'Area(um2)', ...
            'Perimeter', ...
            'Circularity', ...
            'Max dFF', ...
            'Duration 50% to 50%', ...
            'Duration 10% to 10%', ...
            'Rising duration 10% to 90%', ...
            'Decaying duration 90% to 10%',...
            'dat AUC', ...
        	'dFF AUC', ...
            'Number of Events', ...
            'Cell location (0,perivascular;1,adjacent;2,none)', ...
            'Red label', ...
            'dFF'};
        resultsFinal.Properties.VariableNames = updatedColumnNames;    
        
        %Plot dFF curves
        % Get the number of rows in the table
        numCells = size(resultsFinal,1);      
        % Create a figure
        dFF_curve = figure('Visible', 'on');   
        % Plot each row
        hold on
        for i = 1:numCells
            % Extract the i-th row of the column
            rowData = resultsFinal.dFF{i};
            
            % Plot the curve for the i-th row
            plot(rowData);
            
            % Add labels and legend if needed
            xlabel('Frames');
            ylabel('dFF');
            xlim=900;
            title('Curve Plot');
            sprintf(['Cell ' , num2str(i)]);
        end
        legend();
        saveas(dFF_curve, (fullfile(outputDirFOV, strcat(fileTemp,'_dFFcurve_allCells'))));
                 
        % Save results file for single experiment
        % save metadata inside FOV folder
        save(fullfile(outputDirFOV, strcat(fileTemp,'_analysis'))); % save metadata inside FOV folder       
        save(fullfile(outputDirAnimal, strcat(fileTemp,'_analysis'))); % save metadata inside animal folder

        % Convert the cell array column to a cell array of character vectors
        resultsFinal_spreadsheet = resultsFinal;
        resultsFinal_spreadsheet.dFF = cellfun(@(x) mat2str(x), resultsFinal_spreadsheet.dFF, 'UniformOutput', false);
        writetable(resultsFinal_spreadsheet,fullfile(outputDirFOV,strcat(fileTemp,"_resultsFinalByCell")),"WriteRowNames",true,"WriteVariableNames", true,"FileType","spreadsheet"); %save resultsFinal inside FOV folder
        writetable(resultsFinal_spreadsheet,fullfile(outputDirAnimal,strcat(fileTemp,"_resultsFinalByCell")),"WriteRowNames",true,"WriteVariableNames", true, "FileType","spreadsheet"); %save resultsFinal to animal folder
    end
end

